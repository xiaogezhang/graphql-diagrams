import {
  DiagramModel,
  DefaultLinkModel,
  DefaultPortModel,
  DiagramEngine,
} from '@projectstorm/react-diagrams';

import tinycolor from 'tinycolor2';

import {ListNodeModel} from '../../node/ListNodeModel';
import {SimpleTextListItemType} from '../../list/SimpleTextListItem';
import {
  ConditionNode,
  DeferNode,
  FetchNode,
  FlattenNode,
  ParallelNode,
  PlanNode,
  QueryPlan,
  QueryPlanFieldNode,
  QueryPlanInlineFragmentNode,
  QueryPlanSelectionNode,
  SequenceNode,
  SubscriptionNode,
} from '@apollo/query-planner';
import {TreeNode, layout} from '../../layout';
import {DocumentNode, Kind, parse, print, visit} from 'graphql';
import {
  ClickableTextDict,
  MultiLineText,
  MultiLineTextListItemType,
} from '../../list/MultiLineTextListItem';
import React from 'react';
import { DefaultDiagramEngine } from '../../DefaultDiagramEngine';
import { TargetType } from '../../list/ClickableText';

const MIN_NODE_COUNT: number = 50;

export function useQueryPlanGraph(queryPlan?: string, queryStr?: string) {
  const [graph, setGraph] = React.useState<{
    engine?: DiagramEngine;
    nodeCount?: number;
  }>({});
  React.useEffect(() => {
    if (queryPlan) {
      const engine = new DefaultDiagramEngine();
      const model = createQueryPlanGraph(queryPlan, queryStr);
      const nodes = model?.getNodes();
      // divide by 4 because usually there are 4 nodes on average are placed
      // in each row/column by our simple layout algorithm. So the number of rows
      // will be about nodes.length/4. It's not a strictly number, just some estimate.
      // so we don't allocate too big or too small canvas. Otherwise it wastes
      // memory if too big, or need scroll if too small.
      const nodeCount =
        (nodes?.length ?? 0) / 4 < MIN_NODE_COUNT
          ? MIN_NODE_COUNT
          : (nodes?.length ?? 0) / 4;
      if (model) {
        engine.setModel(model);
      }
      setGraph((_) => ({
        engine: engine,
        nodeCount: nodeCount,
      }));
    } else {
      setGraph((_) => ({nodeCount: 0})); 
    }
  }, [queryPlan, queryStr]);
  return graph;
}

/**
 * Basically takes query plan JSON representation as input and generate a diagram model for UI.
 *
 * This works for query plan generated by Apollo server.
 *
 * @param queryPlanStr JSON string representation of the query plan. Usually generated from server
 * @param queryStr the query for this query plan
 * @returns
 */
export function createQueryPlanGraph(
  queryPlanStr: string,
  queryStr?: string,
): DiagramModel {
  const diagramModel = new DiagramModel();
  const queryPlan = JSON.parse(queryPlanStr) as QueryPlan;
  process(diagramModel, queryPlan, queryStr);

  return diagramModel;
}

/**
 * Below are constants defined for the color for the different types of elements in the diagram
 * Considering to move them into context so they are not hard coded here.
 */
const QueryPlanNodeColor = 'CornFlowerBlue';
const ParallelNodeColor: string = 'Cyan';
const ConditionNodeColor: string = tinycolor('Cyan').lighten(40).toRgbString();
const FetchNodeColor: string = 'LimeGreen';
const FetchNodeHeaderColor: string = 'Yellow';
const FetchNodeSectionTitleColor: string = 'DarkMagenta';
const VariablesColor: string = 'MediumSeaGreen';
const RequireBackGroundColor: string = 'LightGreen';
const FlattenNodeColor: string = tinycolor('LightGreen')
  .lighten(15)
  .toRgbString();
const FlattenNodePathColor: string = 'Indigo';
const DeferNodeColor: string = tinycolor('Brown').lighten(50).toRgbString();
const SubscriptionNodeColor: string = 'SlateGrey';

const planLinkColor = 'CadetBlue';
const dependingLinkColor = 'ForestGreen';

/**
 * TreeNode is mainly used internally for layout purpose. Layout is using a
 * simple BFS algorithm to calculate the coordinate in the diagram, so we need
 * an internal tree representation.
 *
 * @param nodeModel The model for the node in the diagram
 * @returns a tree node that contains the model
 */
function createTreeNode(nodeModel: ListNodeModel): TreeNode {
  const name = nodeModel.getOptions().name;
  const treeNode = {
    node: nodeModel,
    rowsCount: 0,
    width: name ? (name.length ?? 0) + 2 : 8,
    children: [],
  };
  return treeNode;
}

/**
 * Each tree node has one incoming port and several outgoing ports, as the tree
 * node may have children nodes
 */
type ResultPorts = {
  treeNode?: TreeNode;
  outPorts: DefaultPortModel[];
  depth: number;
};

/**
 * Process the node for different types, they are nodes in query plan.
 *
 * @param diagramModel the diagram model used to create the diagram UI
 * @param parent the parent node in the query plan for current node
 * @param node
 * @param fetchNodes a map from ID to fetch node, as other nodes may reference a fetch node
 * @param relation
 * @returns
 */
function processNode(
  diagramModel: DiagramModel,
  parent: ResultPorts,
  node: PlanNode,
  fetchNodes: Map<string, ListNodeModel>,
  relation?: string,
): ResultPorts {
  switch (node.kind) {
    case 'Sequence':
      return processSequenceNode(
        diagramModel,
        parent,
        node as SequenceNode,
        fetchNodes,
        relation,
      );
    case 'Parallel':
      return processParallelNode(
        diagramModel,
        parent,
        node as ParallelNode,
        fetchNodes,
        relation,
      );
    case 'Fetch':
      return processFetchNode(
        diagramModel,
        parent,
        node as FetchNode,
        fetchNodes,
        relation,
      );
    case 'Condition':
      return processConditionNode(
        diagramModel,
        parent,
        node as ConditionNode,
        fetchNodes,
        relation,
      );
    case 'Defer':
      return processDeferNode(
        diagramModel,
        parent,
        node as DeferNode,
        fetchNodes,
        relation,
      );
    case 'Flatten':
      return processFlattenNode(
        diagramModel,
        parent,
        node as FlattenNode,
        fetchNodes,
        relation,
      );
    default:
      return {outPorts: [], depth: 0};
  }
}

/**
 * Connect ports in UI.
 *
 * @param diagramModel connect outports to incoming ports in the UI
 * @param linkColor each pair of (inport, outport) will create a link. Different
 *        types of links have different color.
 * @param outPorts
 * @param inPort
 * @param label link may have a label to provide more info
 */
function connectPorts(
  diagramModel: DiagramModel,
  linkColor: string,
  outPorts: DefaultPortModel[],
  inPort: DefaultPortModel,
  label?: string,
): void {
  outPorts.forEach((outPort) => {
    const link = outPort.link<DefaultLinkModel>(inPort);
    link.setWidth(2);
    link.setColor(linkColor);
    link.setLocked(true);
    if (label) {
      link.addLabel(label);
    }
    diagramModel.addLink(link);
  });
}

/**
 * Process sequence node in query plan
 */
function processSequenceNode(
  diagramModel: DiagramModel,
  parent: ResultPorts,
  node: SequenceNode,
  fetchNodes: Map<string, ListNodeModel>,
  relation?: string,
): ResultPorts {
  const steps = node.nodes;
  const stepPorts: ResultPorts[] = [];
  let ports = parent;
  steps.forEach((step, index) => {
    const curPorts = processNode(
      diagramModel,
      ports,
      step,
      fetchNodes,
      index === 0 ? relation : undefined,
    );
    stepPorts.push(curPorts);
    ports = curPorts;
  });
  const len = stepPorts.length;
  if (len === 0) {
    return parent;
  }
  return {
    outPorts: stepPorts[len - 1].outPorts,
    treeNode: stepPorts[len - 1].treeNode,
    depth: stepPorts[len - 1].depth,
  };
}

function createAndConnect(
  diagramModel: DiagramModel,
  parent: ResultPorts,
  name: string,
  color: string,
  relation?: string,
): ResultPorts {
  const nodeModel = new ListNodeModel({
    name: name,
    color: color,
  });
  const inPort = nodeModel.addInPort('in');
  nodeModel.setInPort(inPort);
  inPort.setLocked(true);
  const outPort = nodeModel.addOutPort('out');
  nodeModel.setOutPort(outPort);
  outPort.setLocked(true);
  const treeNode = createTreeNode(nodeModel);

  const parentTreeNode = parent.treeNode;
  const parentOutPorts = parent.outPorts;
  const parentDepth = parent.depth;
  if (parentOutPorts) {
    connectPorts(diagramModel, planLinkColor, parentOutPorts, inPort, relation);
  }
  if (parentTreeNode) {
    parentTreeNode.children.push(treeNode);
  }
  diagramModel.addNode(nodeModel);
  return {
    treeNode: treeNode,
    outPorts: [outPort],
    depth: parentDepth + 1,
  };
}

/**
 * Parallel node in query plan
 */
function processParallelNode(
  diagramModel: DiagramModel,
  parent: ResultPorts,
  node: ParallelNode,
  fetchNodes: Map<string, ListNodeModel>,
  relation?: string,
): ResultPorts {
  const curParent = createAndConnect(
    diagramModel,
    parent,
    'Parallel',
    ParallelNodeColor,
    relation,
  );
  const threads = node.nodes;
  const outPorts: DefaultPortModel[] = [];
  let maxDepth = curParent.depth;
  let curTreeNode = curParent.treeNode;
  threads.forEach((thread) => {
    const curPorts = processNode(diagramModel, curParent, thread, fetchNodes);
    if (curPorts.outPorts) {
      outPorts.push(...curPorts.outPorts);
    }
    if (curPorts.depth > maxDepth) {
      maxDepth = curPorts.depth;
      curTreeNode = curPorts.treeNode;
    }
  });

  return {outPorts: outPorts, treeNode: curTreeNode, depth: maxDepth};
}

/**
 * Process fetch node in query plan
 */
function processFetchNode(
  diagramModel: DiagramModel,
  parent: ResultPorts,
  node: FetchNode,
  fetchNodes: Map<string, ListNodeModel>,
  relation?: string,
): ResultPorts {
  const curParent = createAndConnect(
    diagramModel,
    parent,
    'Fetch (' + node.serviceName + ')',
    FetchNodeColor,
    relation,
  );
  const curParentTreeNode = curParent.treeNode;
  const kindRow = curParentTreeNode?.node.createItem(MultiLineTextListItemType);
  const kindStr: string[] = ['${kind} ' + (node.operationName ?? '')];
  const sectionDict: ClickableTextDict = {
    kind: {label: node.operationKind, color: FetchNodeSectionTitleColor},
    variables: {label: 'Variable Usages', color: FetchNodeSectionTitleColor},
    requires: {label: 'Requires', color: FetchNodeSectionTitleColor},
  };
  if (node.serviceName) {
    const header = curParentTreeNode?.node.createHeader(
      MultiLineTextListItemType,
    );
    const headerLabel: string[] = ['Fetch (${' + node.serviceName + '})'];
    sectionDict[node.serviceName] = {
      label: node.serviceName, 
      color: FetchNodeHeaderColor,
      target: {
        type: TargetType.SCHEMA,
        value: node.serviceName,
      }
    };
    if (header) {
      header.setContent({
        content: headerLabel,
        initNumberOfRows: 1,
        clickableTexts: sectionDict,
      });
    }
  }
  kindRow?.setContent({
    content: kindStr,
    backgroundColor: FetchNodeColor,
    initNumberOfRows: 1,
    clickableTexts: sectionDict,
  });
  if (curParentTreeNode) {
    curParentTreeNode.rowsCount++;
  }
  let maxWidth = curParentTreeNode?.width ?? 0;
  if (kindStr.length > maxWidth) {
    maxWidth = kindStr.length;
  }
  if (node.variableUsages && node.variableUsages.length > 0) {
    const varsRow = curParentTreeNode?.node.createItem(
      MultiLineTextListItemType,
    );
    const varsLines: string[] = [];
    varsLines.push('${variables}');
    if (maxWidth < 17) {
      maxWidth = 17;
    }
    node.variableUsages.forEach((variable) => {
      varsLines.push(singleIndent + singleIndent + variable);
      if (variable.length + 4 > maxWidth) {
        maxWidth = variable.length + 4;
      }
    });
    const varsContent: MultiLineText = {
      content: varsLines,
      backgroundColor: VariablesColor,
      initNumberOfRows: 3,
      clickableTexts: sectionDict,
    };
    varsRow?.setContent(varsContent);
    if (curParentTreeNode) {
      curParentTreeNode.rowsCount += node.variableUsages.length + 1;
    }
  }

  const requires: QueryPlanSelectionNode[] | undefined = node.requires;

  if (requires && requires.length > 0 && curParent.treeNode) {
    const selections = ['${requires}'];
    selections.push('{');
    selections.push(...printQueryPlanSelections(singleIndent, requires));
    selections.push('}');
    const requiresRow = curParent.treeNode.node.createItem(
      MultiLineTextListItemType,
    );
    const requiresContent: MultiLineText = {
      content: selections,
      backgroundColor: RequireBackGroundColor,
      initNumberOfRows: 3,
      clickableTexts: sectionDict,
    };
    for (let i = 0; i < 3 && i < selections.length; i++) {
      if (maxWidth < selections[i].length) {
        maxWidth = selections[i].length;
      }
    }
    requiresRow.setContent(requiresContent);
    curParent.treeNode.rowsCount += 3;
  }

  const row = curParentTreeNode?.node.createItem(MultiLineTextListItemType);
  const rowOutPort = curParentTreeNode?.node.addOutPort('fetching');
  row?.setOutPort(rowOutPort);
  rowOutPort?.setLocked(true);

  const operationStr = print(flattenEntitiesField(parse(node.operation)));
  const lines = operationStr.split(/\r?\n/);
  const content: MultiLineText = {
    content: lines,
    backgroundColor: FetchNodeColor,
    initNumberOfRows: 12,
  };
  for (let i = 0; i < 12 && i < lines.length; i++) {
    if (maxWidth < lines[i].length) {
      maxWidth = lines[i].length;
    }
  }
  row?.setContent(content);
  if (curParentTreeNode) {
    curParentTreeNode.rowsCount += 12;
  }
  if (node.id && curParentTreeNode?.node) {
    fetchNodes.set(node.id, curParentTreeNode.node);
  }
  if (curParentTreeNode) {
    curParentTreeNode.width = maxWidth;
  }
  return {
    depth: curParent.depth,
    treeNode: curParent.treeNode,
    outPorts: rowOutPort ? [rowOutPort] : curParent.outPorts,
  };
}

/**
 * Process condition node in query plan
 */
function processConditionNode(
  diagramModel: DiagramModel,
  parent: ResultPorts,
  node: ConditionNode,
  fetchNodes: Map<string, ListNodeModel>,
  relation?: string,
): ResultPorts {
  const curParent = createAndConnect(
    diagramModel,
    parent,
    'Condition',
    ConditionNodeColor,
    relation,
  );
  const nodeModel = curParent.treeNode?.node;
  const outPort = nodeModel?.addOutPort('condition');
  const row = nodeModel?.createItem(SimpleTextListItemType);
  if (curParent.treeNode) {
    curParent.treeNode.rowsCount++;
  }
  row?.setOutPort(outPort);
  outPort?.setLocked(true);
  row?.setContent({
    label: node.condition,
    backgroundColor: ConditionNodeColor,
  });
  const newParent: ResultPorts = {
    treeNode: curParent.treeNode,
    depth: curParent.depth,
    outPorts: outPort ? [outPort] : [],
  };
  const ifNode = node.ifClause
    ? processNode(diagramModel, newParent, node.ifClause, fetchNodes, 'if')
    : null;
  const elseNode = node.elseClause
    ? processNode(diagramModel, newParent, node.elseClause, fetchNodes, 'else')
    : null;
  const outPorts: DefaultPortModel[] = [];
  let treeNode = curParent.treeNode;
  let depth = curParent.depth;
  if (ifNode) {
    ifNode.outPorts && outPorts.push(...ifNode.outPorts);
    treeNode = ifNode.treeNode;
    depth = ifNode.depth;
  }
  if (elseNode) {
    elseNode.outPorts && outPorts.push(...elseNode.outPorts);
    treeNode = elseNode.treeNode;
    depth = elseNode.depth;
  }
  return {treeNode: treeNode, depth: depth, outPorts: outPorts};
}

/**
 * Process defer node in query plan
 */
function processDeferNode(
  diagramModel: DiagramModel,
  parent: ResultPorts,
  node: DeferNode,
  fetchNodes: Map<string, ListNodeModel>,
  relation?: string,
): ResultPorts {
  const curParent = createAndConnect(
    diagramModel,
    parent,
    'Defer',
    DeferNodeColor,
    relation,
  );
  const nodeModel = curParent.treeNode?.node;
  const outPort = nodeModel?.addOutPort('primary');
  const row = nodeModel?.createItem(SimpleTextListItemType);
  if (curParent.treeNode) {
    curParent.treeNode.rowsCount++;
  }
  row?.setOutPort(outPort);
  outPort?.setLocked(true);
  row?.setContent({
    label: node.primary.subselection,
    backgroundColor: DeferNodeColor,
  });
  const primaryPorts = node.primary.node
    ? processNode(
        diagramModel,
        {
          treeNode: curParent.treeNode,
          depth: curParent.depth,
          outPorts: outPort ? [outPort] : [],
        },
        node.primary.node,
        fetchNodes,
        'primary',
      )
    : null;
  const outPorts: DefaultPortModel[] = [];
  let treeNode = primaryPorts ? primaryPorts.treeNode : curParent.treeNode;
  let maxDepth = primaryPorts ? primaryPorts.depth : curParent.depth;
  if (primaryPorts && primaryPorts.outPorts) {
    outPorts.push(...primaryPorts.outPorts);
  }

  const deferredOutPort = nodeModel?.addOutPort('deferred');
  const deferredRow = nodeModel?.createItem(SimpleTextListItemType);
  if (curParent.treeNode) {
    curParent.treeNode.rowsCount++;
  }
  deferredRow?.setOutPort(deferredOutPort);
  deferredOutPort?.setLocked(true);
  deferredRow?.setContent({
    label: 'deferred',
    backgroundColor: DeferNodeColor,
  });
  const newParent: ResultPorts = {
    treeNode: curParent.treeNode,
    depth: curParent.depth,
    outPorts: deferredOutPort ? [deferredOutPort] : [],
  };
  node.deferred.forEach((deferred) => {
    if (deferred.node) {
      const deferredPorts = processNode(
        diagramModel,
        newParent,
        deferred.node,
        fetchNodes,
        deferred.subselection,
      );
      if (deferredPorts.depth > maxDepth) {
        maxDepth = deferredPorts.depth;
        treeNode = deferredPorts.treeNode;
      }
      outPorts.push(...deferredPorts.outPorts);
      const deferredInPort = deferredPorts.treeNode?.node.getInPort();
      if (deferredInPort) {
        deferred.depends.forEach((depend) => {
          const fetchNode = fetchNodes.get(depend.id);
          if (fetchNode) {
            const fetchOutPort = fetchNode.getOutPort() as DefaultPortModel;
            const link = fetchOutPort.link<DefaultLinkModel>(deferredInPort);
            link.setWidth(2);
            link.setColor(dependingLinkColor);
            link.setLocked(true);
            if (depend.deferLabel) {
              link.addLabel(depend.deferLabel);
            }
            diagramModel.addLink(link);
          }
        });
      }
    }
  });
  return {treeNode: treeNode, depth: maxDepth, outPorts: outPorts};
}

/**
 * Process flatten node in query plan
 */
function processFlattenNode(
  diagramModel: DiagramModel,
  parent: ResultPorts,
  node: FlattenNode,
  fetchNodes: Map<string, ListNodeModel>,
  relation?: string,
): ResultPorts {
  const curParent = createAndConnect(
    diagramModel,
    parent,
    'Flatten (' + node.path.join('.').replaceAll('@', '[]') + ')',
    FlattenNodeColor,
    relation,
  );
  const curParentTreeNode = curParent.treeNode;
  const header = curParentTreeNode?.node.createHeader(
    MultiLineTextListItemType,
  );
  const headerLabel: string[] = ['Flatten (${path})'];
  const sectionDict: ClickableTextDict = {
    path: {
      label: node.path.join('.').replaceAll('@', '[]'),
      color: FlattenNodePathColor,
    },
  };
  if (header) {
    header.setContent({
      content: headerLabel,
      initNumberOfRows: 1,
      clickableTexts: sectionDict,
    });
  }
  return processNode(diagramModel, curParent, node.node, fetchNodes);
}

/**
 * Process subscription node in query plan
 */
function processSubscriptionNode(
  diagramModel: DiagramModel,
  node: SubscriptionNode,
): void {
  const curParent = createAndConnect(
    diagramModel,
    {outPorts: [], depth: 0},
    'Subscription',
    SubscriptionNodeColor,
  );
  const fetchNodes = new Map<string, ListNodeModel>();
  processFetchNode(
    diagramModel,
    curParent,
    node.primary,
    fetchNodes,
    'primary',
  );
  if (node.rest) {
    processNode(diagramModel, curParent, node.rest, fetchNodes, 'rest');
  }
}

/**
 * Process the query plan and generate the model for the diagram UI
 *
 * @param diagramModel
 * @param node the root node for the query plan
 * @param queryStr the query for the query plan. It's used for display purpose only.
 *        It's not parsed or processed in this function.
 */
function processQueryPlan(
  diagramModel: DiagramModel,
  node: PlanNode,
  queryStr?: string,
): void {
  const nodeModel = new ListNodeModel({
    name: 'Query Plan',
    color: QueryPlanNodeColor,
  });
  diagramModel.addNode(nodeModel);
  const treeNode = createTreeNode(nodeModel);
  const parent: ResultPorts = {
    treeNode: treeNode,
    depth: 0,
    outPorts: [],
  };
  let maxWidth = 16;
  if (queryStr) {
    const row = nodeModel.createItem(MultiLineTextListItemType);

    const lines = queryStr.split(/\r?\n/);
    const truncatedLines = lines;
    const content: MultiLineText = {
      content: truncatedLines,
      backgroundColor: QueryPlanNodeColor,
      initNumberOfRows: 12,
    };
    for (let i = 0; i < 12 && i < truncatedLines.length; i++) {
      if (maxWidth < truncatedLines[i].length) {
        maxWidth = truncatedLines[i].length;
      }
    }
    row.setContent(content);
    treeNode.rowsCount += 15;
    treeNode.width = maxWidth;
  }
  const rowHeight: number = 20;
  const yGap: number = 40;

  const fetchNodes = new Map<string, ListNodeModel>();
  processNode(diagramModel, parent, node, fetchNodes);
  nodeModel.setPosition(10, 10);
  const startX = 40; //(maxWidth * charWidth + xGap) / 3;
  const startY =
    treeNode.rowsCount * rowHeight +
    (treeNode.rowsCount >= 5 ? yGap : yGap * 3);
  layout(treeNode.children, startX, startY);
}

function process(
  diagramModel: DiagramModel,
  plan: QueryPlan,
  queryStr?: string,
) {
  const node = plan.node;
  if (node) {
    if (node.kind === 'Subscription') {
      processSubscriptionNode(diagramModel, node);
    } else {
      processQueryPlan(diagramModel, node, queryStr);
    }
  }
}

function flattenEntitiesField(node: DocumentNode): DocumentNode {
  return visit(node, {
    OperationDefinition: ({operation, selectionSet}) => {
      const firstSelection = selectionSet.selections[0];
      if (
        operation === 'query' &&
        firstSelection.kind === Kind.FIELD &&
        firstSelection.name.value === '_entities'
      ) {
        return firstSelection.selectionSet;
      }
      // we don't want to print the `query { }` definition either for query plan printing
      return selectionSet;
    },
  });
}

const singleIndent = '  ';

function printQueryPlanSelection(
  indent: string,
  selection: QueryPlanSelectionNode,
): string[] {
  switch (selection.kind) {
    case 'Field':
      return printQueryPlanField(indent, selection as QueryPlanFieldNode);
    case 'InlineFragment':
      return printQueryPlanInlineFragment(
        indent,
        selection as QueryPlanInlineFragmentNode,
      );
  }
}

function printQueryPlanField(
  indent: string,
  field: QueryPlanFieldNode,
): string[] {
  const result: string[] = [];
  const fieldStr =
    indent + field.name + (field.alias ? ' as ' + field.alias : '');
  if (field.selections) {
    result.push(fieldStr + ' {');
    const children = printQueryPlanSelections(
      indent + singleIndent,
      field.selections,
    );
    result.push(...children);
    result.push(indent + '}');
  } else {
    result.push(fieldStr);
  }
  return result;
}

function printQueryPlanInlineFragment(
  indent: string,
  fragment: QueryPlanInlineFragmentNode,
): string[] {
  const result: string[] = [];
  result.push(
    fragment.typeCondition ? indent + fragment.typeCondition + ' {' : '{',
  );
  const children = printQueryPlanSelections(
    indent + singleIndent,
    fragment.selections,
  );
  result.push(...children);
  result.push(indent + '}');
  return result;
}

function printQueryPlanSelections(
  indent: string,
  selections?: QueryPlanSelectionNode[],
): string[] {
  const result: string[] = [];
  if (!selections || selections.length === 0) {
    return result;
  }
  selections.forEach((selection) => {
    const children = printQueryPlanSelection(indent, selection);
    result.push(...children);
  });
  return result;
}
